  완료된 작업 (`vmtest` 폴더 내):

   1. Node.js 애플리케이션: package.json, index.js
   2. 컨테이너화 설정: Dockerfile
   3. Kubernetes 배포 설정: k8s/deployment.yaml, k8s/service.yaml
   4. CI/CD 파이프라인: Jenkinsfile (빌드 → 테스트 → 이미지 생성 → Harbor 푸시 → K8s 배포)

  ---

  가장 중요한 다음 단계: Jenkins 설정

  Jenkinsfile이 올바르게 동작하려면 Jenkins 시스템에 몇 가지 중요한 설정이 필요합니다.

  1. Jenkins 에이전트(서버) 설정

  파이프라인을 실행하는 Jenkins 에이전트(또는 마스터)에 다음 작업이 반드시 선행되어야 합니다.

   * 필수 도구 설치: docker, kubectl, node (Node.js)가 설치되어 있어야 합니다.
   * Harbor 'Insecure Registry' 등록 (매우 중요):
      Harbor가 사설 IP(192.168.63.99)에서 실행되므로, Docker는 기본적으로 보안되지 않은 레지스트리로 간주하여 이미지 푸시를 차단합니다. 이를 해결하려면 Jenkins 에이전트 서버에서 아래와 같이 Docker 데몬 설정을 변경해야 합니다.

       * /etc/docker/daemon.json 파일을 열고 아래 내용을 추가 (파일이 없으면 새로 생성) 하고 Docker를 재시작하세요.

   1     {
   2       "insecure-registries" : ["192.168.63.99"]
   3     }

       * Docker 재시작 명령어: sudo systemctl restart docker

  2. Jenkins Credentials 생성

  Jenkins가 Harbor와 Kubernetes에 접근할 수 있도록 접속 정보를 Credentials에 안전하게 등록해야 합니다.

   * Harbor 로그인 정보:
       * 경로: Manage Jenkins > Credentials > System > Global credentials > Add Credentials
       * Kind: Username with password
       * Username: Harbor 사용자 ID
       * Password: Harbor 사용자 비밀번호
       * ID: harbor-credentials  (✅ Jenkinsfile에 지정된 것과 정확히 일치해야 합니다)

   * Kubernetes 클러스터 접속 정보:
       * 경로: 위와 동일
       * Kind: Secret file
       * File: K8s 마스터 노드(192.168.63.97)에 접속할 수 있는 kubeconfig 파일을 업로드합니다. (보통 ~/.kube/config 경로에 있습니다)
       * ID: kubeconfig-credentials (✅ Jenkinsfile에 지정된 것과 정확히 일치해야 합니다)

  3. 파이프라인 실행

   1. 지금까지 생성된 vmtest 폴더 전체를 GitHub 등 원격 Git 저장소에 푸시합니다.
   2. Jenkins에서 New Item > Pipeline 프로젝트를 생성하고, Pipeline script from SCM 옵션을 통해 Git 저장소를 연결합니다.
   3. Build Now를 실행하면 파이프라인이 작동하여 Harbor에 이미지를 올리고 Kubernetes에 자동으로 배포합니다.

  4. 배포된 애플리케이션 확인

  배포가 성공적으로 완료되면, 서비스 YAML에 설정한 대로 워커 노드의 IP와 NodePort를 통해 앱에 접속할 수 있습니다.

   * 접속 주소: http://192.168.63.98:30080

  위 설정들을 마치고 파이프라인을 실행하면, 코드 변경 시 자동으로 K8s 클러스터에 배포되는 CI/CD 환경이 완성됩니다.     



  ##

  1단계: 소스코드 준비 및 Git 저장소에 업로드

  먼저 로컬 컴퓨터에서 생성된 파일들을 Git 저장소(예: GitHub)에 올려야 Jenkins가 가져갈 수 있습니다.

   1. `vmtest` 디렉토리로 이동합니다.
   1     cd vmtest

   2. Git을 초기화하고 모든 파일을 추가 후 커밋합니다.

   1     git init
   2     git add .
   3     git commit -m "Initial setup for Jenkins K8s pipeline"

   3. 원격 Git 저장소를 생성합니다.
       * GitHub, GitLab 등 사용하시는 서비스에 접속하여 vmtest (또는 원하는 이름)으로 새로운 비공개(Private) 저장소를     
         만듭니다.

   4. 로컬 저장소와 원격 저장소를 연결하고 코드를 푸시(Push)합니다.
       * 아래 명령어에서 <YOUR_GIT_REPOSITORY_URL> 부분을 3번 단계에서 만든 저장소의 URL로 변경하여 실행하세요.
   1     git remote add origin <YOUR_GIT_REPOSITORY_URL>
   2     git push -u origin main
      (참고: 기본 브랜치명이 `master`인 경우 `main` 대신 `master`를 사용하세요.)

  ---

  2단계: Jenkins 서버 환경 설정

  Jenkins를 실행하는 서버(VM)에 접속하여 파이프라인에 필요한 도구들을 설치하고 설정합니다.

   1. Jenkins 서버에 SSH로 접속합니다.

   2. 필수 도구들을 설치합니다. (Ubuntu 22.04+ 기준)

    1     # 패키지 목록 업데이트
    2     sudo apt-get update
    3
    4     # Docker, Kubectl, Node.js 설치
    5     sudo apt-get install -y docker.io kubectl nodejs npm

       1. 자바(JDK) 설치 (Jenkins 실행에 필수)
   1     sudo apt-get update
   2     sudo apt-get install -y openjdk-17-jre

   2. Jenkins 저장소 설정 및 설치
       * Jenkins 설치에 필요한 GPG 키를 추가합니다.
   1         sudo wget -O /usr/share/keyrings/jenkins-keyring.asc \
   2           https://pkg.jenkins.io/debian-stable/jenkins.io-2023.key
       * Jenkins 저장소를 시스템에 추가합니다.

   1         echo "deb [signed-by=/usr/share/keyrings/jenkins-keyring.asc] \
   2           https://pkg.jenkins.io/debian-stable binary/" | sudo tee \
   3           /etc/apt/sources.list.d/jenkins.list > /dev/null
       * 패키지 목록을 다시 업데이트하고 Jenkins를 설치합니다.
   1         sudo apt-get update
   2         sudo apt-get install -y jenkins

   3. Jenkins 서비스 시작 및 부팅 시 자동 실행 설정
   1     sudo systemctl start jenkins
   2     sudo systemctl enable jenkins

   4. 파이프라인에 필요한 다른 도구들 설치
   1     sudo apt-get install -y docker.io kubectl nodejs npm

   5. Jenkins 사용자를 docker 그룹에 추가
       * 이제 jenkins 사용자가 존재하므로 아래 명령어가 성공적으로 실행됩니다.
   1         sudo usermod -aG docker jenkins

   6. Docker 데몬 설정 (Harbor 연동)
       * /etc/docker/daemon.json 파일을 열고 아래 내용을 추가합니다.
   1         sudo nano /etc/docker/daemon.json

   1         {
   2           "insecure-registries" : ["192.168.63.99"]
   3         }
       * Docker와 Jenkins 서비스를 재시작하여 모든 변경사항을 적용합니다.
   1         sudo systemctl restart docker
   2         sudo systemctl restart jenkins
    6
    7     # Jenkins 사용자를 docker 그룹에 추가하여 sudo 없이 docker 명령 사용
    8     sudo usermod -aG docker jenkins
    9
   10     # 변경사항 적용을 위해 Jenkins 서비스 재시작
   11     sudo systemctl restart jenkins

   3. Docker가 Harbor 사설 레지스트리를 신뢰하도록 설정합니다. (매우 중요)
       * daemon.json 파일을 엽니다.
   1         sudo nano /etc/docker/daemon.json
       * 아래 내용을 붙여넣고 저장합니다. (파일이 비어있으면 그대로 붙여넣기)
   1         {
   2           "insecure-registries" : ["192.168.63.99"]
   3         }
       * Docker 서비스를 재시작하여 설정을 적용합니다.

   1         sudo systemctl restart docker

  ---

  3단계: Jenkins 웹 UI 설정

  이제 Jenkins 웹 화면에서 플러그인과 자격 증명을 설정합니다.

   1. Jenkins 플러그인 설치:
       * Manage Jenkins > Plugins > Available plugins 탭으로 이동합니다.
       * Docker Pipeline, Kubernetes CLI, NodeJS 를 검색하여 설치합니다.

   2. Jenkins Global Tool 설정:
       * Manage Jenkins > Tools 로 이동합니다.
       * NodeJS installations 섹션에서 Add NodeJS를 클릭합니다.
       * Name: node-16 (Jenkinsfile에 명시된 이름과 동일해야 합니다)
       * Install automatically 옵션을 선택하고, 원하는 버전을 선택합니다 (예: NodeJS 16.x).
       * Save를 누릅니다.

   3. Jenkins Credentials 설정:
       * Manage Jenkins > Credentials > System > Global credentials 로 이동합니다.
       * Harbor 자격 증명 추가:
           * Add Credentials 클릭
           * Kind: Username with password
           * ID: harbor-credentials
           * Username / Password: Harbor 로그인 ID/비밀번호 입력
       * Kubernetes 자격 증명 추가:
           * Add Credentials 클릭
           * Kind: Secret file
           * ID: kubeconfig-credentials
           * File: K8s 클러스터 접속용 kubeconfig 파일을 업로드합니다.

  ---

  4단계: Jenkins 파이프라인 생성 및 실행

  모든 설정이 끝났습니다. 이제 Jenkins 프로젝트를 만들고 실행합니다.

   1. Jenkins 메인 화면에서 `New Item` 을 클릭합니다.
   2. 이름(예: vmtest-pipeline)을 입력하고 `Pipeline` 을 선택한 후 OK를 누릅니다.
   1. Jenkins 메인 화면에서 `New Item` 을 클릭합니다.
   2. 이름(예: vmtest-pipeline)을 입력하고 `Pipeline` 을 선택한 후 OK를 누릅니다.
   3. Pipeline 탭으로 스크롤하여 Definition 항목을 `Pipeline script from SCM` 으로 변경합니다.
   4. SCM 항목에서 `Git` 을 선택하고, Repository URL에 1단계에서 사용한 Git 저장소 URL을 입력합니다.
       * (비공개 저장소인 경우 Credentials 항목에서 Git 접속용 자격 증명을 추가해야 합니다.)
   5. Branch Specifier가 */main 또는 */master로 되어있는지 확인합니다.
   6. Save를 누르고, 프로젝트 화면에서 `Build Now` 를 클릭하여 파이프라인을 실행합니다.




프리즈마 콘솔에 jenkins 연결을 위한 provider 진행 시 생성된 스크립트를 기준으로 작업을 진행해야 프리즈마 콘솔에서도 연결을 진행할 수 있음 아님 코드가 꼬임

pipeline {
        agent any
        
        environment {
            PRISMA_API_URL="https://api.jp.prismacloud.io"
        }
        
        stages {
            stage('Checkout') {
              steps {
                  git branch: 'main', url: 'http://192.168.63.99:80'
                  stash includes: '**/*', name: 'source'
              }
            }
            stage('Checkov') {
                steps {
                    withCredentials([string(credentialsId: 'PC_USER', variable: 'pc_user'),string(credentialsId: 'PC_PASSWORD', variable: 'pc_password')]) {
                        script {
                            docker.image('bridgecrew/checkov:latest').inside("--entrypoint=''") {
                              unstash 'source'
                              try {
                                  sh 'checkov -d . --use-enforcement-rules -o cli -o junitxml --output-file-path console,results.xml --bc-api-key ${pc_user}::${pc_password} --repo-id  /192.168.63.99:80 --branch main'
                                  junit skipPublishingChecks: true, testResults: 'results.xml'
                              } catch (err) {
                                  junit skipPublishingChecks: true, testResults: 'results.xml'
                                  throw err
                              }
                            }
                        }
                    }
                }
            }
        }
        options {
            preserveStashes()
            timestamps()
        }
    }



    443 포트 문제 해결: 앞서 안내해 드린 대로, Jenkins에 등록된 kubeconfig 파일의 서버 주소를 http://...로 수정했는지 다시 한번 확인해 주세요.
   * Prisma Cloud 인증 정보: 새로 추가된 Checkov Security Scan 단계가 정상적으로 동작하려면 Jenkins에 PC_USER와 PC_PASSWORD라는 ID로 Prisma Cloud 인증
     정보(Credential)가 등록되어 있어야 합니다.


      알겠습니다. 두 가지 설정을 모두 완료했는데도 문제가 발생한다면, 원인을 찾기 위해 좀 더 상세한 확인이 필요합니다. 아래 단계에 따라 문제를 진단해 볼 수
  있습니다.

  가장 중요한 것은 Jenkins의 빌드 로그를 확인하는 것입니다. 실패한 단계(Stage)의 "Console Output"을 보면 어떤 명령어에서 어떤 오류가 발생했는지 상세한
  내용을 알 수 있습니다.

  다음 단계 문제 해결 가이드

  어떤 단계에서 오류가 발생하는지에 따라 아래 내용을 확인해 보세요.

  1. 'Deploy to Kubernetes' 단계에서 실패하는 경우 (포트 문제)

  kubeconfig 파일은 올바르게 수정했지만, 여전히 연결이 안 된다면 네트워크나 다른 설정의 문제일 수 있습니다.

   * Jenkins 에이전트 서버에서 직접 `kubectl` 실행:
      Jenkins가 설치된 서버에 직접 접속해서, Jenkins가 사용하는 것과 동일한 kubeconfig 파일로 아래 명령어를 실행해 보세요.
   1     # Jenkins가 사용하는 kubeconfig 파일의 경로를 지정해야 합니다.
   2     kubectl --kubeconfig /var/lib/jenkins/secrets/kubeconfig-credentials get nodes
       * 성공한다면: Jenkins 내부의 kubectl 실행 환경이나 withKubeconfig 플러그인에 문제가 있을 수 있습니다.
       * 실패한다면: kubeconfig 파일의 내용이 잘못되었거나, Jenkins 서버와 Kubernetes 클러스터(Master 노드) 간의 네트워크 방화벽이 80 포트를 차단하고
         있을 가능성이 매우 높습니다.

   * 네트워크 방화벽 확인:
      Jenkins 서버에서 Kubernetes 마스터 노드의 IP와 80 포트로 TCP 통신이 가능한지 방화벽 설정을 확인해야 합니다. (예: ufw, iptables 또는 클라우드 환경의
  보안 그룹 등)

  2. 'Checkov Security Scan' 단계에서 실패하는 경우 (Prisma Cloud 문제)

  Prisma Cloud 인증 정보가 올바른데도 실패한다면, API 주소나 Credential 설정 방식의 문제일 수 있습니다.

   * Jenkins Credential 정보 재확인:
       * Jenkins > Manage Jenkins > Credentials 에서 ID가 PC_USER, PC_PASSWORD 와 정확히 일치하는지 다시 확인해 주세요. (띄어쓰기나 대소문자 포함)       
       * Credential의 종류(Type)가 'Secret text' 로 되어 있는지 확인해 주세요.

   * Prisma Cloud API 주소 확인:
       * Jenkinsfile에 설정된 PRISMA_API_URL (https://api.jp.prismacloud.io) 이 사용하시는 계정의 API 엔드포인트가 맞는지 Prisma Cloud 콘솔에서 다시 한번
         확인해 보세요.

   * Jenkins 에이전트 서버에서 직접 `curl` 실행:
      Jenkins 서버에 접속해서 아래 명령어를 실행하여 Prisma Cloud API 서버와 통신이 가능한지 확인해 보세요.
   1     curl -v https://api.jp.prismacloud.io
       * 이 명령어가 실패한다면, Jenkins 서버의 DNS 설정이나 외부로 나가는 방화벽에 문제가 있는 것입니다.

  ---

  만약 위 방법으로도 해결이 어렵다면, Jenkins Console Output의 에러 메시지를 저에게 보여주시면 더 정확한 원인 분석이 가능합니다.  